<!DOCTYPE html>
<html lang="en">

<head>
	<title>CM20219 – Coursework 2 – WebGL</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			margin: 0;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
			display: block;
		}
	</style>
</head>

<body>
	<script src="three-r134.js"></script>
	<script>
		"use strict"; // https://stackoverflow.com/q/1335851/72470

		// Global variables that are available in all functions.
		// Note: You can add your own here, e.g. to store the rendering mode.
		var camera, scene, renderer, mesh, line, points;
		let e, f, v;

		//Variables for camera rotations.
		let rotateLeft, rotateRight, rotateUp, rotateDown;
		let focusPoint = new THREE.Vector3(0, 0, 0);

		//Variables for camera translatiion.
		let cameraX = 0;
		let cameraY = 0;
		let cameraZ = 0;

		// Initialise the scene, and draw it for the first time.
		init();
		animate();

		// Listen for keyboard events, to react to them.
		// Note: there are also other event listeners, e.g. for mouse events.
		document.addEventListener('keydown', handleKeyDown);

		// Scene initialisation. This function is only run once, at the very beginning.
		function init() {
			scene = new THREE.Scene();

			// Set up the camera, move it to (3, 4, 5) and look at the origin (0, 0, 0).
			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(3, 4, 5);
			camera.lookAt(new THREE.Vector3(0, 0, 0));

			// Draw a helper grid in the x-z plane (note: y is up).
			scene.add(new THREE.GridHelper(10, 20, 0xffffff));

			/*
			*	TASK: Draw a cube (requirement 1).
			*/ 
			const geometry = new THREE.BoxGeometry();
			//Using phong material as the basic material isn't affected by lighting.
			const material = new THREE.MeshPhongMaterial( {color:0x44aa88} );
			mesh =  new THREE.Mesh( geometry, material );
			scene.add( mesh );

			//creating an edge line cube
			const edges = new THREE.EdgesGeometry( geometry );
			line = new THREE.LineSegments( edges, new THREE.LineBasicMaterial( 
				{ color: 0xffffff} ) );
			
			// Setting up geometry for the points
			const newMaterial = new THREE.PointsMaterial({
				color: 'red',
				size: 0.2,
			});
			points = new THREE.Points( geometry,newMaterial );
			
			/*
			*	TASK: Visualise the axes of the global coordinate system (requirment 2).
			*/
			const axeshelper = new THREE.AxesHelper(5)
            scene.add(axeshelper)

			/*
			*	TASK: add more complex lighting for 'face' rendering mode (requirement 4).
			*/
			// Adding ligthing to reflect of the cube and thus create a 3D effect whilst rotation.
			{
				const color = 0xFFFFFF;
				const intensity = 1;
				const light = new THREE.DirectionalLight( color, intensity );
				light.position.set( 1, 6, 9);
				scene.add(light);
			}
			// Basic ambient lighting.
			// scene.add(new THREE.AmbientLight(0xffffff));

			// Set up the Web GL renderer.
			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setPixelRatio(window.devicePixelRatio); // HiDPI/retina rendering
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);

			//renderer.render(scene, camera);

			// Handle resizing of the browser window.
			window.addEventListener('resize', handleResize, false);
		}

		// Handle resizing of the browser window.
		function handleResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		}

		// Animation loop function. This function is called whenever an update is required.
		function animate() {
			requestAnimationFrame( animate );

			/*
			*	TASK: Implement code to help with translating the camera.(Requirement 5).
			*/
			camera.translateX(cameraX);
            camera.translateY(cameraY);
            camera.translateZ(cameraZ);

			/*
			*	TASK: This is a good place for code that rotates your cube (requirement 3).
			*/
			if(f){
				rotation(mesh);
			}
			if(e){
				rotation(line);
			}
			if(v){
				rotation(points);
			}
			
			// Render the current scene to the screen.
			renderer.render(scene, camera);
		}

		// Handle keyboard presses.
		function handleKeyDown(event) {
			switch (event.key) {

				/*
				* TASK: Adding code for render modes (Requirement 4).
				*/
				// Render modes.
				case 'f': // f = face
					//alert('TASK: add code for face render mode (requirement 4).');
					scene.remove( line );
					scene.add( mesh );
					scene.remove( points );
					e = false;
					v = false;
					f = true;
					break;

				case 'e': // e = edge
					//alert('TASK: add code for edge render mode (requirement 4).');
					scene.remove( mesh );
					scene.add( line );
					scene.remove( points );
					e = true;
					v = false;
					f = false;
					break;

				case 'v': // v = vertex
					//alert('TASK: add code for vertex render mode (requirement 4).');
					scene.remove( mesh );
					scene.remove( line );
					scene.add( points );
					e = false;
					v = true;
					f = false;
					break;
				
				/*
				*	TASK: add code for starting/stopping rotations (requirement 3).
				*/
				case 'g':
					//For starting rotations.
					if(mesh.parent === scene){
						//rotation(mesh);
						f = true;
					}
					if(line.parent === scene){
						//rotation(line);
						e = true;
					}
					if(points.parent === scene){
						//rotation(line);
						v = true;
					}
					break;
					break;
				
				case 's':
					//For stopping roations.
					if(mesh.parent === scene){
						//rotation(mesh);
						f = false
					}
					if(line.parent === scene){
						//rotation(line);
						e = false;
					}
					if(points.parent === scene){
						//rotation(line);
						v = false;
					}
					break;
			}

			/*
			* TASK: Implement code to help with translating the camera.(Requirement 5).
			*/
			switch(event.keyCode){
				case 37: // left arrow = translate camera left
                    if (cameraX != -0.01) {
                        cameraX = -0.01;
                     }
                    else {
                        cameraX = 0;
                      }
                     break;

                case 39: // right arrow = translate camera right
                     if (cameraX != 0.01) {
                        cameraX = 0.01;
                     }
					else {
						cameraX = 0;
					}
					break;

				case 40: // down arrow = translate camera down
					if (cameraY != -0.01) {
						cameraY = -0.01;
					}
					else {
						cameraY = 0;
					}
					break;

				case 38: // up arrow = translate camera up
					if (cameraY != 0.01) {
						cameraY = 0.01;
					}
					else {
						cameraY = 0;
					}
					break;

				case 16: // left shift = translate camera forwards
					if (cameraZ != -0.01) {
						cameraZ = -0.01;
					}
					else {
						cameraZ = 0;
					}
					break;

				case 17: // left control = translate camera backwards
					if (cameraZ != 0.01) {
						cameraZ = 0.01;
					}
					else {
						cameraZ = 0;
					}
					break;
			}
		}

		function rotation(objects){
			objects.rotation.x += 0.01;
			objects.rotation.y += 0.01;
			objects.rotation.z += 0.01;
		}

		function rotationStop(object){
			objects.rotation.x = 0;
			objects.rotation.y = 0;
			objects.rotation.z = 0;
		}

	</script>
</body>

</html>